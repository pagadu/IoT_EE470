/*******************************************************
 * Title: LDR_RGB_Buzzer_ESP8266  (Active-HIGH Buzzer)
 * -----------------------------------------------------
 * Program Detail:
 *   Purpose: Read light level from an HW-486 photoresistor (AO→A0),
 *            convert ADC to Lux via a 2-point calibration, print Lux
 *            every 0.5 s to Serial, drive an RGB LED via PWM to
 *            indicate brightness, and sound an *active-HIGH* buzzer
 *            when Lux is below a user threshold. Typing 'B' forces
 *            the buzzer ON for ~5 s.
 *   Inputs:   A0 (analog from photoresistor), Serial command 'B'
 *   Outputs:  Serial @115200 ("ADC=…, Lux=…"); RGB LED on D5/D6/D7;
 *             *Active-HIGH* buzzer on D2 (HIGH = ON)
 *   Date:     September 28, 2025
 *   Compiler: Arduino IDE / PlatformIO (ESP8266 core)
 *   Author:   Alexander Pagaduan
 *   Versions:
 *     V1 – Initial: 2-point Lux calibration, LED PWM mapping,
 *          threshold buzzer + serial override (0.5 s sampling)
 * -----------------------------------------------------
 * File Dependencies:
 *   - Arduino.h
 * -----------------------------------------------------
 * Hardware Notes:
 *   - HW-486: VCC→3V3, GND→GND, AO→A0 (use analog output, not DO).
 *   - RGB LED uses 220 Ω series resistors on R/G/B; common to GND for
 *     common-cathode (set COMMON_ANODE=1 if using common-anode to 3V3).
 *   - Buzzer is *active-HIGH*: + (or S) → D2, – → GND.
 *     Keep BUZZER_ACTIVE_LOW set to 0 so HIGH = ON.
 *******************************************************/


#include <Arduino.h>

/* ====== USER SETTINGS ====== */
#define PIN_R D5
#define PIN_G D6
#define PIN_B D7
#define PIN_BUZZER D2

#define COMMON_ANODE 0            // 0=common-cathode LED, 1=common-anode
// ACTIVE-HIGH buzzer in use → keep this at 0 (means HIGH turns ON)
#define BUZZER_ACTIVE_LOW 0       // 0: HIGH=ON (active-HIGH buzzer), 1: LOW=ON (active-LOW buzzer)

float LUX_THRESHOLD = 50.0f;      // buzzer trips when Lux < threshold
const unsigned long SAMPLE_MS = 500, BUZZ_FORCE_MS = 5000;

// Two-point calibration (replace with your measured pairs)
const int   ADC1 = 200;   const float Lux1 = 20.0f;
const int   ADC2 = 800;   const float Lux2 = 300.0f;
/* =========================== */

unsigned long tNext=0, tBuzzOff=0;
bool buzzForced=false;
float mLux=0, bLux=0;

inline int pwm(int v){ return COMMON_ANODE ? (1023 - v) : v; }
inline void setRGB(int r,int g,int b){   // each 0..1023
  analogWrite(PIN_R, pwm(r));
  analogWrite(PIN_G, pwm(g));
  analogWrite(PIN_B, pwm(b));
}

// Active-HIGH buzzer behavior: with BUZZER_ACTIVE_LOW==0, HIGH turns buzzer ON
inline void buzzerOn(){  digitalWrite(PIN_BUZZER, BUZZER_ACTIVE_LOW ? LOW  : HIGH); }
inline void buzzerOff(){ digitalWrite(PIN_BUZZER, BUZZER_ACTIVE_LOW ? HIGH : LOW ); }

template<typename T> T clamp(T v,T lo,T hi){ return v<lo?lo:(v>hi?hi:v); }
float adcToLux(int a){ return mLux*a + bLux; }

// White -> Red as Lux increases (keep R high; fade G & B)
void setLedFromLux(float lux){
  const float Lmin=0.0f, Lmax=400.0f;            // adjust Lmax for your room
  float t = clamp((lux - Lmin)/(Lmax - Lmin), 0.0f, 1.0f);
  int r = 1023;
  int gb = 1023 - (int)round((1.0f - t) * 1023.0f);     // white at dark, red at bright
  Serial.print("setLedFromLux lux="); Serial.println(lux,1);
  Serial.print("setLedFromLux t="); Serial.println(t,1); 
  Serial.print("setLedFromLux r="); Serial.println(r,1); 
  Serial.print("setLedFromLux gb="); Serial.println(gb,1);
  setRGB(r, gb, gb);
}

void setup(){
  analogWriteRange(1023);
  pinMode(PIN_R, OUTPUT); pinMode(PIN_G, OUTPUT); pinMode(PIN_B, OUTPUT);
  pinMode(PIN_BUZZER, OUTPUT); buzzerOff();

  Serial.begin(115200); delay(200);

  // calibration: Lux = m*ADC + b
  mLux = (Lux2 - Lux1) / float(ADC2 - ADC1);
  bLux = Lux1 - mLux * float(ADC1);

  // quick white at start so you see LED is wired
  setRGB(1023,1023,1023);
  Serial.println("LDR+RGB+Buzzer ready. Type 'B' to buzz ~5s.");
}

void loop(){
  // manual buzzer force
  while(Serial.available()){
    char c=Serial.read();
    if(c=='B'||c=='b'){
      buzzForced=true; tBuzzOff = millis()+BUZZ_FORCE_MS;
      buzzerOn(); Serial.println("Buzzer: FORCED ON (5 s)");
    }
  }
  if(buzzForced && (long)(millis()-tBuzzOff)>=0){
    buzzForced=false; buzzerOff(); Serial.println("Buzzer: forced OFF");
  }

  if((long)(millis()-tNext)>=0){
    tNext = millis()+SAMPLE_MS;

    int adc = analogRead(A0);     // HW-486 AO -> A0
    float lux = adcToLux(adc);

    setLedFromLux(lux);

    if(!buzzForced){
      if(lux < LUX_THRESHOLD) buzzerOn();  // ACTIVE-HIGH: HIGH = ON
      else                    buzzerOff();
    }

    Serial.print("ADC="); Serial.print(adc);
    Serial.print(" Lux="); Serial.println(lux,1); 
  }

  delay(1);
}
