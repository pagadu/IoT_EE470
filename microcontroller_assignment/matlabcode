% --- data ---
trueLux = [0 200 500 800 1200 1600 2000 2400 2800 3000];
Vmeas   = [0.02 0.25 0.58 0.91 1.28 1.73 2.16 2.70 3.04 3.18];

% Fit V = m*Lux + b, then invert to measured Lux
p  = polyfit(trueLux, Vmeas, 1);  m = p(1);  b = p(2);
Lux_est = max((Vmeas - b)/m, 0);

% Percent error (skip 0 Lux)
errPct = 100*(Lux_est - trueLux) ./ max(trueLux,1);
errPct(trueLux==0) = NaN;

% R^2
SSres = sum((Vmeas - polyval(p,trueLux)).^2);
SStot = sum((Vmeas - mean(Vmeas)).^2);
R2    = 1 - SSres/SStot;

figure('Color','w'); t=tiledlayout(1,1); t.Padding='compact'; t.TileSpacing='compact';

% ---- LEFT AXIS: measured vs true + ideal ----
yyaxis left
hold on
h_meas = plot(trueLux, Lux_est, 'o-','LineWidth',1.8,'MarkerSize',7,...
              'Color',[0.15 0.45 0.85]);                         % blue
h_ideal = plot(trueLux, trueLux, 'k--','LineWidth',1.4);          % dashed
xlabel('True Lux (phone app)')
ylabel('Measured Lux (from model)')
grid on

% ---- RIGHT AXIS: error bars ----
yyaxis right
h_err = bar(trueLux, errPct, 0.35, 'FaceColor',[0.85 0.25 0.25],...
            'EdgeColor','none');
ylabel('Error (%)')

% ---- 2-line title (no "\n" text) ----
title({ 'Sensor Calibration and Error Analysis', ...
        sprintf('V = %.6f Â· Lux %+ .6f    (R^2 = %.4f)', m, b, R2) });

% ---- Legend: include the error series too ----
% Build legend using handles from both axes
yyaxis left
legend([h_meas, h_ideal, h_err], ...
       {'Measured vs True Lux','Ideal (y = x)','Error (%)'}, ...
       'Location','northwest');

% Niceties
xlim([min(trueLux)-50, max(trueLux)+50]);
yyaxis left
ylim([0, max([Lux_est trueLux]) + 0.1*max(trueLux)]);
yyaxis right
ylim([nanmin(errPct)-5, nanmax(errPct)+5]);
